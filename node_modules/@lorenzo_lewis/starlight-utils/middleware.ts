import {
  defineRouteMiddleware,
  type StarlightRouteData,
} from "@astrojs/starlight/route-data";
import { AstroError } from "astro/errors";
import config from "virtual:starlight-utils/config";

export const onRequest = defineRouteMiddleware((context) => {
  // Initialize object
  context.locals.starlightUtils = {
    navLinks: {}
  };

  // Logic for navLinks
  if (config?.navLinks && config.navLinks.length > 0) {
    const starlightRouteSidebar = context.locals.starlightRoute.sidebar;
    const allNavLinks: Record<string, typeof starlightRouteSidebar> = {};
    const filteredSidebar: typeof starlightRouteSidebar = [];
    const processedSidebarLabels: string[] = [];

    // Process each navLinks configuration
    config.navLinks.forEach((navLinkConfig, index) => {
      if (!navLinkConfig.leading) {
        throw new AstroError(
          `No leading configuration was specified for navLinks entry ${index} in the Astro config.`
        );
      }

      const sidebarLabel = navLinkConfig.leading.useSidebarLabelled;

      if (!sidebarLabel) {
        throw new AstroError(
          `No sidebar label was specified for the ${JSON.stringify(navLinkConfig.leading)} entry in the Astro config.`
        );
      }

      // Check for duplicate sidebar labels
      if (processedSidebarLabels.includes(sidebarLabel)) {
        throw new AstroError(
          `Duplicate sidebar label \`${sidebarLabel}\` found in navLinks configuration.`
        );
      }
      processedSidebarLabels.push(sidebarLabel);

      const navLinksForThisSidebar: typeof starlightRouteSidebar = [];

      starlightRouteSidebar.forEach((entry) => {
        if (entry.label === sidebarLabel) {
          navLinksForThisSidebar.push(entry);
        }
      });

      if (navLinksForThisSidebar.length != 1 || !navLinksForThisSidebar[0]) {
        throw new AstroError(
          `Could not find the sidebar labelled \`${sidebarLabel}\` that was referenced in the Starlight Utils config.`
        );
      }

      if (navLinksForThisSidebar[0].type !== "group") {
        throw new AstroError(
          `\`${navLinksForThisSidebar[0].label}\` cannot be used with multi-sidebar.
      
        The sidebar entry specified in the Astro config must be either a group or autogenerated.
      
        See https://starlight.astro.build/guides/sidebar/#groups and https://starlight.astro.build/guides/sidebar/#autogenerated-groups for more details.`
        );
      }

      if (navLinksForThisSidebar[0].entries.some((entry) => entry.type !== "link")) {
        throw new AstroError(
          `Only links can be specified for nav links. No groups or autogenerated types are allowed.`
        );
      }

      // Add the entries from this sidebar to the object with sidebarLabel as key
      allNavLinks[sidebarLabel] = [...navLinksForThisSidebar[0].entries];
    });

    // Filter out all processed sidebars from the main sidebar
    starlightRouteSidebar.forEach((entry) => {
      if (!processedSidebarLabels.includes(entry.label)) {
        filteredSidebar.push(entry);
      }
    });
    // Set navLinks value with the constructed object
    context.locals.starlightUtils.navLinks = allNavLinks;
    // Set the filtered sidebar
    context.locals.starlightRoute.sidebar = filteredSidebar;
  }

  // Logic for multi-sidebar
  if (config?.multiSidebar) {
    // All entries must be group types
    const data = context.locals.starlightRoute.sidebar.map((entry) => {
      if (entry.type != "group") {
        throw new AstroError(
          `\`${entry.label}\` cannot be used with multi-sidebar.
  
    Each top-level \`sidebar\` item in the Starlight config must be either a group or autogenerated.
  
    See https://starlight.astro.build/guides/sidebar/#groups and https://starlight.astro.build/guides/sidebar/#autogenerated-groups for more details.`
        );
      }

      // Recursively check if a group of sidebar entries contains the current page
      const findIfIsCurrent = (
        entry: StarlightRouteData["sidebar"][number]
      ): boolean => {
        if (entry.type === "link") {
          return entry.isCurrent;
        }
        return entry.entries.some((item) => findIfIsCurrent(item));
      };

      const isCurrentSidebar = findIfIsCurrent(entry);

      return {
        isCurrentSidebar,
        sidebar: [...entry.entries],
        label: entry,
      };
    });
    // If the current page being built isn't contained in a sidebar, then render the first sidebar
    if (data[0] && !data.some(({ isCurrentSidebar }) => isCurrentSidebar)) {
      data[0].isCurrentSidebar = true;
    }
    context.locals.starlightUtils.multiSidebar = data;
  }
});
